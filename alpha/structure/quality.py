from __future__ import annotations

# NOTE: File automatically generated by assistant
from dataclasses import dataclass, field, asdict

import pandas as pd

from alpha.core.indicators import atr


@dataclass
class QualityCfg:
    min_break_margin_norm: float = 0.25
    ft_bars_min: int = 2
    ft_backslide_tol_mult: float = 0.10
    ft_distance_atr_mult: float = 0.20
    retest_window_bars: int = 20
    retest_tol_atr_mult: float = 0.15
    sweep_window_bars: int = 20
    sweep_tol_atr_mult: float = 0.10
    atr_window: int = 14
    quality_weights: dict = field(
        default_factory=lambda: {
            "break_margin_norm": 0.35,
            "followthrough": 0.35,
            "retest": 0.15,
            "sweep": 0.15,
        }
    )
    quality_grades: dict = field(
        default_factory=lambda: {
            "A": [0.75, 1.00],
            "B": [0.55, 0.75],
            "C": [0.00, 0.55],
        }
    )


def _grade_from_score(score: float, grades: dict) -> str:
    for grade, (lo, hi) in grades.items():
        if lo <= score <= hi:
            return grade
    return "C"


def qualify_events(df: pd.DataFrame, events: pd.DataFrame, cfg: QualityCfg) -> pd.DataFrame:
    atr_series = atr(df, window=cfg.atr_window)
    eps = 1e-12
    out_rows: list[dict] = []

    for _, ev in events.iterrows():
        idx = int(ev["idx"])
        ref_price = float(ev["ref_price"])
        direction = ev["direction"]
        atr_at_break = float(atr_series.iloc[idx]) if idx < len(atr_series) else 0.0
        thr_atr = max(eps, atr_at_break)

        # Break margin gate
        bm_norm = float(ev.get("break_margin_norm", 0.0))
        break_margin_norm_pass = bm_norm >= cfg.min_break_margin_norm

        # Follow-through window
        ft_window = df.iloc[idx + 1 : idx + 1 + cfg.ft_bars_min]
        ft_bars = len(ft_window)
        if direction == "up":
            cond_backslide = (
                ft_window["low"].min() >= ref_price - thr_atr * cfg.ft_backslide_tol_mult
                if not ft_window.empty
                else False
            )
        else:
            cond_backslide = (
                ft_window["high"].max() <= ref_price + thr_atr * cfg.ft_backslide_tol_mult
                if not ft_window.empty
                else False
            )
        atr_ft = atr_series.reindex(ft_window.index).fillna(thr_atr)
        ft_dist_series = (ft_window["close"] - ref_price).abs() / atr_ft.replace(0, eps)
        ft_avg_dist_atr = float(ft_dist_series.mean()) if not ft_dist_series.empty else 0.0
        ft_pass = (
            ft_bars >= cfg.ft_bars_min
            and cond_backslide
            and ft_avg_dist_atr >= cfg.ft_distance_atr_mult
        )

        # Retest detection
        retest_win = df.iloc[idx + 1 : idx + 1 + cfg.retest_window_bars]
        atr_rt = atr_series.reindex(retest_win.index).fillna(thr_atr)
        if direction == "up":
            cond = retest_win["low"] <= ref_price + atr_rt * cfg.retest_tol_atr_mult
        else:
            cond = retest_win["high"] >= ref_price - atr_rt * cfg.retest_tol_atr_mult
        if cond.any():
            first_idx = cond.idxmax()
            has_retest = True
            retest_time = first_idx
            if direction == "up":
                dist = abs(ref_price - retest_win.loc[first_idx, "low"])
            else:
                dist = abs(retest_win.loc[first_idx, "high"] - ref_price)
            retest_dist_atr = float(dist / max(eps, atr_rt.loc[first_idx]))
        else:
            has_retest = False
            retest_time = pd.NaT
            retest_dist_atr = float("nan")

        # Sweep detection
        start = max(0, idx - cfg.sweep_window_bars)
        sweep_win = df.iloc[start:idx]
        atr_sw = atr_series.reindex(sweep_win.index).fillna(thr_atr)
        if direction == "up":
            cond_sweep = (
                (sweep_win["high"] >= ref_price - atr_sw * cfg.sweep_tol_atr_mult)
                & (sweep_win["close"] <= ref_price + atr_sw * cfg.sweep_tol_atr_mult)
            )
            sweep_dist = max(0.0, sweep_win["high"].max() - ref_price)
        else:
            cond_sweep = (
                (sweep_win["low"] <= ref_price + atr_sw * cfg.sweep_tol_atr_mult)
                & (sweep_win["close"] >= ref_price - atr_sw * cfg.sweep_tol_atr_mult)
            )
            sweep_dist = max(0.0, ref_price - sweep_win["low"].min())
        if cond_sweep.any():
            has_sweep = True
            first_sweep_idx = cond_sweep.idxmax()
            sweep_bars_back = idx - df.index.get_loc(first_sweep_idx)
        else:
            has_sweep = False
            sweep_bars_back = -1
        sweep_dist_atr = float(sweep_dist / max(eps, atr_at_break))

        is_valid = break_margin_norm_pass and ft_pass

        w = cfg.quality_weights
        bm_norm_score = min(1.0, bm_norm / (cfg.min_break_margin_norm * 2))
        ft_norm = min(1.0, ft_avg_dist_atr / (cfg.ft_distance_atr_mult * 2))
        quality_score = (
            w.get("break_margin_norm", 0.0) * bm_norm_score
            + w.get("followthrough", 0.0) * ft_norm
            + w.get("retest", 0.0) * (1.0 if has_retest else 0.0)
            + w.get("sweep", 0.0) * (1.0 if has_sweep else 0.0)
        )
        grade = _grade_from_score(quality_score, cfg.quality_grades)

        row = ev.to_dict()
        row.update(
            {
                "break_margin_norm_pass": break_margin_norm_pass,
                "ft_bars": ft_bars,
                "ft_pass": ft_pass,
                "ft_avg_dist_atr": ft_avg_dist_atr,
                "has_retest": has_retest,
                "retest_time": retest_time,
                "retest_dist_atr": retest_dist_atr,
                "has_sweep": has_sweep,
                "sweep_bars_back": sweep_bars_back,
                "sweep_dist_atr": sweep_dist_atr,
                "is_valid": is_valid,
                "quality_score": quality_score,
                "quality_grade": grade,
            }
        )
        out_rows.append(row)

    return pd.DataFrame(out_rows, columns=list(events.columns) + [
        "is_valid",
        "break_margin_norm_pass",
        "ft_bars",
        "ft_pass",
        "ft_avg_dist_atr",
        "has_retest",
        "retest_time",
        "retest_dist_atr",
        "has_sweep",
        "sweep_bars_back",
        "sweep_dist_atr",
        "quality_score",
        "quality_grade",
    ])


def summarize_quality(events_q: pd.DataFrame, cfg: QualityCfg) -> dict:
    n_events = int(len(events_q))
    n_valid = int(events_q["is_valid"].sum()) if n_events else 0
    share_valid = float(n_valid / n_events) if n_events else 0.0
    grade_counts = (
        events_q["quality_grade"].value_counts().to_dict() if n_events else {}
    )
    return {
        "n_events_in": n_events,
        "n_valid": n_valid,
        "share_valid": share_valid,
        "grade_counts": grade_counts,
        "med_break_margin_norm": float(
            events_q["break_margin_norm"].median(skipna=True)
        )
        if n_events
        else 0.0,
        "med_ft_bars": float(events_q["ft_bars"].median(skipna=True)) if n_events else 0.0,
        "med_ft_avg_dist_atr": float(
            events_q["ft_avg_dist_atr"].median(skipna=True)
        )
        if n_events
        else 0.0,
        "retest_rate": float(events_q["has_retest"].mean()) if n_events else 0.0,
        "sweep_rate": float(events_q["has_sweep"].mean()) if n_events else 0.0,
        "params": asdict(cfg),
    }
